#import "BCTextFrame.h"
#import "BCTextLine.h"
#import "BCTextNode.h"
#import "BCImageNode.h"
#import "BCBlockBorder.h"
#import "ThemeMgr.h"
#import <CoreText/CoreText.h>

#import "ImageManager.h"
#import "CurUserInfo.h"

#import "PicNet.h"
#import "PicDao.h"

typedef enum {
	BCTextNodePlain = 0,
	BCTextNodeBold = 1,
	BCTextNodeItalic = 1 << 1,
	BCTextNodeLink = 1 << 2,
} BCTextNodeAttributes;

@interface BCTextFrame ()
- (UIFont *)fontWithAttributes:(BCTextNodeAttributes)attr;

@property (nonatomic, retain) NSMutableArray *lines;
@property (nonatomic, retain) BCTextLine *currentLine;
@end

@implementation BCTextFrame
@synthesize fontSize, height, width, lines, textColor, linkColor, delegate, indented, links, singleLine, linksInCurrentLine,maxValue,maxWidth,isSendOut;

- (id)init {
	if ((self = [super init])) {
        self.textColor = LIGHT_BROWN_TEXT_COLOR;
		self.linkColor = RGBCOLOR(0, 112, 191);
	}
	
	return self;
}

+ (BCTextFrame*)textFromHTML:(NSString*)source {
    return [[[[self class] alloc] initWithHTML:source] autorelease];
}

- (id)initWithHTML:(NSString *)html {
    if (NULL == html) {
        html = @"";
    }
    
	textLengthLimit = NULL;
	textLengthCount = 0;
	
	if ((self = [self init])) {
		CFStringEncoding cfenc = CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding);
		CFStringRef cfencstr = CFStringConvertEncodingToIANACharSetName(cfenc);
		const char *enc = CFStringGetCStringPtr(cfencstr, 0);
		// let's set our xml doc to doc because we don't want to free node
		// (which we didn't alloc) but we want to free a doc we alloced
		doc = node = (xmlNode *)htmlReadDoc((xmlChar *)[html UTF8String],
									   "",
									   enc,
									   XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
	}
	
	return self;
}
/*
- (id)initWithHTML:(NSString *)html isSendOut:(BOOL) isSendOuter maxWidth:(CGFloat) maxWid{
    isSendOut = isSendOuter;
    maxWidth = maxWid;
    if (!html) {
        html = @"";
    }
    
	if ((self = [self init])) {
		CFStringEncoding cfenc = CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding);
		CFStringRef cfencstr = CFStringConvertEncodingToIANACharSetName(cfenc);
		const char *enc = CFStringGetCStringPtr(cfencstr, 0);
		// let's set our xml doc to doc because we don't want to free node
		// (which we didn't alloc) but we want to free a doc we alloced
		doc = node = (xmlNode *)htmlReadDoc((xmlChar *)[html UTF8String],
                                            "",
                                            enc,
                                            XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
	}
	
	return self;
}
*/

- (id)initWithXmlNode:(xmlNode *)aNode {
	
	textLengthLimit = NULL;
	textLengthCount = 0;
	
	if ((self = [self init])) {
		node = aNode;
	}
	
	return self;
}

- (BOOL)touchBeganAtPoint:(CGPoint)point {
	for (NSValue *link in self.links) {
		NSArray *rects = [self.links objectForKey:link];
		for (NSValue *v in rects) {
			if (CGRectContainsPoint([v CGRectValue], point)) {
				touchingLink = link;
				if ([(NSObject *)self.delegate respondsToSelector:@selector(link: touchedInRects:)])
					[self.delegate link:link touchedInRects:rects];
				return YES;
			}
		}
	}
    return NO;
}

- (BOOL)touchEndedAtPoint:(CGPoint)point {
	if (touchingLink) {
		NSArray *rects = [self.links objectForKey:touchingLink];
		for (NSValue *v in rects) {
			if (CGRectContainsPoint([v CGRectValue], point)) {
				if ([(NSObject *)self.delegate respondsToSelector:@selector(link: touchedUpInRects:)])
                {
                    BOOL isFind = NO;
                    for (BCTextLine *line in self.lines) 
                    {
                        if (!isFind) 
                        {
                            for (BCNode *n in line.stack) 
                            {
                                
                                if (n.src == touchingLink) 
                                {
                                    
                                    NSString *url = (NSString *)touchingLink;
                                    NSString* imageName = [[url pathComponents] lastObject];
                                    
                                    NSString *strPicName = [imageName substringWithRange:NSMakeRange(2, imageName.length - 4)];
                                    
                                    if (!strPicName || !strPicName.length)
                                    {
                                        isFind = YES;
                                        break;
                                    }
                                    
                                    //暗恋通知 特殊处理
                                    if ([FileConfig4Sys instance].bHasWeiboServer)
                                    {
                                        if ( [strPicName isEqualToString:@"set_secretLove_demo.png"]) {
                                            isFind = YES;
                                            break;
                                        }
                                    }

                                    NSString *strPicPath = [NSString stringWithFormat:@"%@/pic/%@",
                                                            [FileConfig4Sys instance].strCachePath,
                                                            strPicName];
                                    
                                    if ([n isKindOfClass:[BCImageNode class]]) {
                                        
                                        BCImageNode *imageNode = (BCImageNode *)n;
                                        
                                        NSError       *error;
                                        NSFileManager *fm    = [NSFileManager defaultManager];
                                        if ([fm fileExistsAtPath:strPicPath])
                                        {
                                            if ([[fm attributesOfItemAtPath:strPicPath error:&error] fileSize] > 10)
                                            {
                                                imageNode.image = [UIImage imageWithContentsOfFile:strPicPath];
                                                
                                            }
                                            else
                                            {                                                
                                                imageNode.image = [self addText:[ThemeMgr imageNamed:@"pic_start.png"] text:LocalizedStringFromFile(BCTextFrame_lb_Text_Downloading) withPicSize:[[PicNet instance] getPicSizeStr:strPicName]];
                                            }
                                        }
                                        else
                                        {
                                            
                                            imageNode.image = [self addText:[ThemeMgr imageNamed:@"pic_start.png"] text:LocalizedStringFromFile(BCTextFrame_lb_Text_Downloading) withPicSize:[[PicNet instance] getPicSizeStr:strPicName]];
                                        }
                                    }

                                    isFind = YES;
                                    break;
                                }
                            }                            
                        }
                    }

                    [self.delegate link:touchingLink touchedUpInRects:rects];
                }

				touchingLink = nil;
                return YES;
			}
		}
	}

    if(YES == [self.delegate respondsToSelector:@selector(noLinkTouchedInBCTextFrame:)]){
        [self.delegate noLinkTouchedInBCTextFrame:self];
    }

	touchingLink = nil;
    return NO;
}

- (BOOL)touchMovedAtPoint:(CGPoint)point {
    if (touchingLink) {
        NSArray *rects = [self.links objectForKey:touchingLink];
        BOOL containPoint = NO;
        for (NSValue *v in rects) {
			if (CGRectContainsPoint([v CGRectValue], point)) {
				containPoint = YES;
                break;
			}
		}
        
        if (!containPoint) {
            if ([(NSObject *)self.delegate respondsToSelector:@selector(link: touchedUpInRects:)])
                [self.delegate link:touchingLink touchedUpInRects:rects];
            
            touchingLink = nil;
            return YES;
        }
    }
    return NO;
}

- (void)touchCancelled {
	touchingLink = nil;
}

- (void)layoutLinksInCurrentLine {
    if (NULL == linksInCurrentLine) {
        return;
    }
    
    for (NSValue* link in linksInCurrentLine) {
        BCTextLine* currentLine = self.currentLine;
        NSMutableArray *linkRectValues = [self.links objectForKey:link];
        for (int i = 0; i < linkRectValues.count; i++) {
            NSValue* linkRectValue = [linkRectValues objectAtIndex:i];
            CGRect linkRect = [linkRectValue CGRectValue];
            
            //当前行的link
            if ((NSInteger)linkRect.origin.y == (NSInteger)currentLine.y && currentLine.height > linkRect.size.height) {
                linkRect.origin.y += currentLine.height / 2 - linkRect.size.height / 2;
                [linkRectValues replaceObjectAtIndex:i withObject:[NSValue valueWithCGRect:linkRect]];
            }
        }
    }
    [linksInCurrentLine removeAllObjects];
}

- (void)pushNewline:(BCTextLine *)line {
	line.indented = self.indented;
	if (0 == self.currentLine.height) {
		self.currentLine.height = self.fontSize;
	}
	self.currentLine = line;
}

- (void)pushNewline {
    //插入新行时,对上一行的链接位置进行调整
    [self layoutLinksInCurrentLine];
    
	[self pushNewline:[[[BCTextLine alloc] initWithWidth:self.width] autorelease]];
}

- (void)addLink:(NSValue *)link forRect:(CGRect)rect {
	NSMutableArray *a = [self.links objectForKey:link];
	if (NULL == a) {
		a = [NSMutableArray array];
		[self.links setObject:a forKey:link];
	}
	
	[a addObject:[NSValue valueWithCGRect:rect]];
    
    //保存当前行的link
    [linksInCurrentLine addObject:link];
}

- (void)pushText:(NSString *)text withFont:(UIFont *)font link:(NSValue *)link {
    CGSize size = [text sizeWithFont:font];
    
    //NSLog(@"size.width=[%f] self.currentLine.widthRemaining=[%f]", size.width , self.currentLine.widthRemaining);
	if (size.width > self.currentLine.widthRemaining) {
		NSRange spaceRange = [text rangeOfCharacterFromSet:[NSCharacterSet newlineCharacterSet]];
		
        //NSLog(@"spaceRange.location=[%d] text.length=[%d] fontSize=[%f]", spaceRange.location , text.length, fontSize);
		// a word that needs to wrap
		if (spaceRange.location == NSNotFound || spaceRange.location == text.length - 1) {
            if (self.currentLine.widthRemaining < fontSize) {
                [self pushNewline];
            }
			
			if (size.width > self.currentLine.widthRemaining)
            {
                // word is too long even for its own line
                NSInteger length = 0;
                NSMutableAttributedString* attributedString = [[NSMutableAttributedString alloc] initWithString:text];
                
                CTFontRef aFont = CTFontCreateWithName((CFStringRef)font.familyName, fontSize, NULL);
                [attributedString addAttribute:(NSString*)kCTFontAttributeName value:(id)aFont range:NSMakeRange(0, text.length)];
                
                CTTypesetterRef typesetter = CTTypesetterCreateWithAttributedString((CFAttributedStringRef)attributedString);
                length = CTTypesetterSuggestLineBreak(typesetter, 0, self.currentLine.widthRemaining);
                [attributedString release];
                CFRelease(aFont);
                CFRelease(typesetter);
    
                NSString *firstPart = [text substringToIndex:length];
                NSInteger oldlen = length;
                //sizeWithFont算出的宽度会更大, 可能会导致死循环, 这里直接addNote
//				[self pushText:lastPart withFont:font link:link];
                size = [firstPart sizeWithFont:font];
                
                //NSLog(@"firstPart=[%@] size=[%f,%f]", firstPart , size.width, size.height);
                
                if ((size.width > self.currentLine.widthRemaining) && self.currentLine.widthRemaining > 0)
                {
                    //字符串转char
                    const char *cText = [text UTF8String];
                    NSInteger widthTotal = 0;
                    
                    //NSString* logStr = @"sizeChar:";
                    for (length = 0; length < [text length]; length++)
                    {
                        //取单个字符的宽度
                        char c = cText[length];
                        NSString *strChar = [NSString stringWithFormat:@"%c",c];
                        CGSize sizeChar = [strChar sizeWithFont:font];
                        //计算总宽度
                        widthTotal += sizeChar.width;
                        //logStr = [logStr stringByAppendingFormat:@"%@(%.1f) ", strChar, sizeChar.width];
                        //if (widthTotal > self.currentLine.widthRemaining)
                        if (widthTotal > self.currentLine.width)
                        {
                            //超出范围则跳出
                            break;
                        }
                    }
                    //NSLog(@"logStr=%@", logStr);
                    //重新获取字符串
                    if (length > oldlen)
                        length = oldlen;
                    firstPart = [text substringToIndex:length];
                    //NSLog(@"length=%d widthTotal=%d, firstPart=%@ length=%d", length, widthTotal, firstPart, length);
                    //NSLog(@"--------");
                    //if (length>18)
                    //    NSLog(@"========");
                    //计算字符串大小
                    size = [firstPart sizeWithFont:font];
                }
                
                BCTextNode *n = [[[BCTextNode alloc] initWithText:firstPart
															 font:font
															width:size.width
														   height:size.height
															 link:link != nil]
								 autorelease];
                if (NULL != link) {
                    [self addLink:link forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
                                                          self.currentLine.y, 
                                                          n.width + 4, n.height)];
                }
                [self.currentLine addNode:n height:size.height];
                
                if (length < text.length) {
                    [self pushNewline]; //断句后插入新行, 防止单词被截断
                    [self pushText:[text substringFromIndex:length]
						  withFont:font
							  link:link];
                }
			} else {
				[self pushText:text withFont:font link:link];
			}
		} else {
			[self pushText:[text substringWithRange:NSMakeRange(0, spaceRange.location + 1)]
				  withFont:font
					  link:link];
			[self pushText:[text substringWithRange:NSMakeRange(spaceRange.location + 1, text.length - (spaceRange.location + 1))]
				  withFont:font
					  link:link];
		}
	} else {
               
		BCTextNode *n = [[[BCTextNode alloc] initWithText:text
													 font:font
													width:size.width
												   height:size.height
													 link:link != nil]
						 autorelease];
		
		if (NULL != link) {
			[self addLink:link forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
												  self.currentLine.y, 
												  n.width + 4, n.height)];
		}
		[self.currentLine addNode:n height:size.height];
	}
}

    //暂时没有用到
- (void)pushImage:(NSString *)src linkTarget:(NSValue *)link {
	UIImage *img = nil;
	BCImageNode *n;
	if ([(NSObject *)self.delegate respondsToSelector:@selector(imageForURL:)]) {
		img = [self.delegate imageForURL:src];
		n = [[[BCImageNode alloc] initWithImage:img link:YES] autorelease];
		if (img.size.width > self.currentLine.widthRemaining) {
			[self pushNewline];
		}
	} 
	
	if (!img) {
		img = [ThemeMgr imageNamed:@"pic_failed.png"];
        n = [[[BCImageNode alloc] initWithImage:img link:NO] autorelease];
		if (img.size.width > self.currentLine.widthRemaining) {
			[self pushNewline];
		}
//		[self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
//											  self.currentLine.y, 
//											  img.size.width + 4, img.size.height)];
        //img.size是原图的大小。而显示在界面上的是缩略图的大小。若上面那样会导致rect计算出错，点击的时候则会取错key。+4是原先就有的，暂时不知道其意图。
        [self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
                                                        self.currentLine.y, 
                                                        [n width] + 4, [n height])];

	}
	
	
	[self.currentLine addNode:(BCTextNode *)n height:img.size.height];
	
	whitespaceNeeded = YES;
	
}

//显示图片，如果没有图片则返回字符串显示
- (NSString*)pushImage:(xmlNode*)curNode link:(NSValue *)link {
    UIImage *img = nil;
	BCImageNode *n = NULL;
    
    char *url = (char *)xmlGetProp(curNode, (xmlChar *)"src");
    if (NULL == url) {
        NSLog(@"BCTextFrame pushImage: src属性没有");
        return @"";
    }
    NSString *src = [NSString stringWithUTF8String:url];
    //    NSLog(@"666666 src: %@",src);
    free(url);
    
    img = [self imageForURL:src];
    if (NULL == img)
    {
        NSLog(@"BCTextFrame pushImage: %@ 图片不存在", src);
        if (YES == [src hasPrefix:@"smiley://"])
        {
            //当系统里没有这个表情图片时使用文字表示
            NSString *str = nil;
            NSString* imageName = [[src pathComponents] lastObject];
            uint32 dwImgId = (uint32)[[imageName substringWithRange:NSMakeRange(2, imageName.length - 4)] intValue];
            NSString *smileyName = [[ImageManager instance] smileyNameForId:dwImgId];
            if (!smileyName || !smileyName.length) {
                str = [NSString stringWithFormat:LocalizedStringFromFile(BCTextFrame_lb_Text_SmileyID), dwImgId];
            } else {
                str = [NSString stringWithFormat:LocalizedStringFromFile(BCTextFrame_lb_Text_SmileyName),smileyName];
            }
            return str;
        }
		else if([src hasPrefix:@"image://"])
		{
			return LocalizedStringFromFile(ChatMsgProcess_Msg_Image);
		}
        return nil;
    }
    
    n = [[[BCImageNode alloc] initWithImage:img link:YES] autorelease];
    n.src = (NSValue *)src;
    
    //获取HTML中指定高宽
    char* sWidth = (char *)xmlGetProp(curNode, (xmlChar *)"width");
    if (sWidth) {
        n.imageWidth = [[NSString stringWithUTF8String:sWidth] intValue];
        xmlFree(sWidth);
    }
    char* sHeight = (char *)xmlGetProp(curNode, (xmlChar *)"height");
    if (sHeight) {
        n.imageHeight = [[NSString stringWithUTF8String:sHeight] intValue];
        xmlFree(sHeight);
    }
    
    //图片宽度大于行宽, 并且为多行, 缩放
    if (!singleLine && n.imageWidth > self.currentLine.width)
	{
        NSInteger tmpWidth = n.imageWidth;
        n.imageWidth = self.currentLine.width;
        n.imageHeight = (NSInteger)((float)n.imageHeight * (float)n.imageWidth / (float)tmpWidth);
    }
	
	//图片高度大于行高，并且为单行, 缩放
    if (singleLine && n.imageHeight > SINGLELINE_HEIGHT)
	{
        NSInteger tmpHeight = n.imageHeight;
        n.imageHeight = SINGLELINE_HEIGHT;
        n.imageWidth = (NSInteger)((float)n.imageWidth * (float)n.imageHeight / (float)tmpHeight);
    }
    
    if (n.imageWidth > self.currentLine.widthRemaining) {
        [self pushNewline];
    }
    
    if (NULL != link) {
        //        [self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2,
        //                                                        self.currentLine.y,
        //                                                        img.size.width + 4, img.size.height)];
        //img.size是原图的大小。而显示在界面上的是缩略图的大小。若上面那样会导致rect计算出错，点击的时候则会取错key。+4是原先就有的，暂时不知道其意图。
        [self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2,
                                                        self.currentLine.y,
                                                        n.imageWidth + 4, n.imageHeight)];
    }
    
    [self.currentLine addNode:(BCTextNode *)n height:n.imageHeight];
	
	whitespaceNeeded = YES;
    return nil;
}

//- (void)pushImage:(xmlNode*)curNode link:(NSValue *)link {
//    UIImage *img = nil;
//	BCImageNode *n;
//    
//    char *url = (char *)xmlGetProp(curNode, (xmlChar *)"src");
//    NSString *src = [NSString stringWithUTF8String:url];
////    NSLog(@"666666 src: %@",src);
//    free(url);
//    
//    img = [self imageForURL:src];
//    if (!img) {
//        NSLog(@"%@ 图片不存在", src);
//        return;
//    }
//    
//    n = [[[BCImageNode alloc] initWithImage:img link:YES] autorelease];
//    n.src = (NSValue *)src;  
//    
//    //获取HTML中指定高宽
//    char* sWidth = (char *)xmlGetProp(curNode, (xmlChar *)"width");
//    if (sWidth) {
//        n.imageWidth = [[NSString stringWithUTF8String:sWidth] intValue];
//        xmlFree(sWidth);
//    }
//    char* sHeight = (char *)xmlGetProp(curNode, (xmlChar *)"height");
//    if (sHeight) {
//        n.imageHeight = [[NSString stringWithUTF8String:sHeight] intValue];
//        xmlFree(sHeight);
//    }
//    
//    //图片宽度大于行宽, 缩放
//    if (n.imageWidth > self.currentLine.width) {
//        NSInteger tmpWidth = n.imageWidth;
//        n.imageWidth = self.currentLine.width - 10;
//        n.imageHeight = (NSInteger)((float)n.imageHeight * (float)n.imageWidth / (float)tmpWidth);
//    }
//    
//    if (n.imageWidth > self.currentLine.widthRemaining) {
//        [self pushNewline];
//    }
//    
//    if (link) {
////        [self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
////                                                        self.currentLine.y, 
////                                                        img.size.width + 4, img.size.height)];
//        //img.size是原图的大小。而显示在界面上的是缩略图的大小。若上面那样会导致rect计算出错，点击的时候则会取错key。+4是原先就有的，暂时不知道其意图。
//        [self addLink:(NSValue *)src forRect:CGRectMake((self.currentLine.width - self.currentLine.widthRemaining) - 2, 
//                                                        self.currentLine.y, 
//                                                        [n width] + 4, [n height])];
//    }
//    
//    
//    [self.currentLine addNode:(BCTextNode *)n height:n.imageHeight];
//	
//	whitespaceNeeded = YES;
//}


- (void)pushBlockBorder {
	[self pushNewline:[[[BCBlockBorder alloc] initWithWidth:self.width] autorelease]];
}

//|| *str == '\r'
- (NSString *)stripWhitespace:(char *)str {
	char *stripped = malloc(strlen(str) + 1);
	int i = 0;
	for (; *str != '\0'; str++) {
		if (*str == ' ' || *str == '\t' || *str == '\n') {
			if (whitespaceNeeded) {
				stripped[i++] = ' ';
				whitespaceNeeded = NO;
			}
		} else {
			whitespaceNeeded = YES;
			stripped[i++] = *str;
		}
	}
	stripped[i] = '\0';
	NSString *strippedString = [NSString stringWithUTF8String:stripped];
	free(stripped);
	return strippedString;
}

- (void)layoutNode: (xmlNode *)n
		attributes: (BCTextNodeAttributes)attr
		linkTarget: (NSValue *)link {
    
    //NSLog(@"here is layoutNode");
    
	if (NULL == n){
		return;
	}
	
	NSUInteger _txtLenLimit = 0;
	if(NULL != textLengthLimit){
		_txtLenLimit = [textLengthLimit unsignedIntegerValue];
	}else{
		_txtLenLimit = INT_MAX;
	}
    
	BOOL bTextLengthOverflow = NO;
	UIFont *textFont = [self fontWithAttributes:attr];
	for (xmlNode *curNode = n; NULL != curNode; curNode = curNode->next) {
        
//        if (NULL != curNode->name) {
//            NSLog(@"node name %s", (char *)curNode->name);
//        }
        if(textLengthCount >= _txtLenLimit){
            //NSLog(@"... fill");
//            [self pushText: @"..."
//                  withFont: textFont
//                      link: link];
            break;
        }
        
		if (curNode->type == XML_TEXT_NODE) {
            //UIFont *textFont = [self fontWithAttributes:attr];
			
			NSString *text = [self stripWhitespace:(char *)curNode->content];
//            text = @"ios新版本版本  功能待排\r\n\
//            1、高端阅读\r\n\
//            2、初始化增加广告图";
            NSArray *arrText = [text componentsSeparatedByString:@"\r"];
           
			if (1 == [arrText count] || 0 == [arrText count]) {
				arrText = [NSArray arrayWithObject:text];
			}
			
			for (NSString *subText in arrText) {
				//NSLog(@"subText (link %x): %@", link, subText);
				NSUInteger iTextSpace = _txtLenLimit - textLengthCount;
				NSUInteger iTextLength = [subText length];
				NSString* _pushTxt = NULL;
				if(iTextLength <= iTextSpace){
                    
					_pushTxt = subText;
					textLengthCount += (iTextLength);
            
					[self pushText: _pushTxt
						  withFont: textFont
							  link: link];
					
					if(1 < [arrText count]){
                        [self pushNewline];
					}
					
					if(textLengthCount == _txtLenLimit){
						bTextLengthOverflow = YES;
						break;
					}
					
				}else{

//                    if(YES == [subText isEqualToString:@"@李耀华"]){
//                        _pushTxt = _pushTxt;
//                    }
                    
                    BOOL bCutOff = YES;
                    if (NULL != curNode->name) {
                        if (!strcmp((char *)curNode->name, "text")) {
                            if(YES == [subText hasPrefix:@"@"] && NULL != link){
                                bCutOff = NO;
                            }
                        }
                    }
                    
                    if(YES == bCutOff){
                        NSRange r;
                        r.length = iTextSpace;
                        r.location = 0;
                        _pushTxt = [subText substringWithRange: r];
                        //NSLog(@"... %@ -> %@...", _pushTxt, _pushTxt);
                        //_pushTxt = [NSString stringWithFormat:@"%@...", _pushTxt];
                    }else{
                        _pushTxt = subText;
                    }
                    textLengthCount += (iTextSpace);
 
					[self pushText: _pushTxt
						  withFont: textFont
							  link: link];
                    
                    if(1 < [arrText count]){
                        [self pushNewline];
					}
					
					bTextLengthOverflow = YES;
					break;
				}
			}
            
            if(YES == bTextLengthOverflow){
                break;
            }
			/*
            if ([arrText count] > 1) {
                for (NSString *subText in arrText) {
		            [self pushText: subText
                          withFont: textFont
                              link: link];
                    [self pushNewline];
                }
            }
            else
            {
                [self pushText:text withFont:textFont link:link];
            }
            */
		} else { // if (curNode->type != XML_TEXT_NODE)
            
			BCTextNodeAttributes childrenAttr = attr;
			
			if (NULL != curNode->name) {
				if (!strcmp((char *)curNode->name, "b")) {
                    //NSLog(@"find nodename b");
					childrenAttr |= BCTextNodeBold;
                    
				} else if (!strcmp((char *)curNode->name, "i")) {
                    //NSLog(@"find nodename i");
					childrenAttr |= BCTextNodeItalic;
                    
				} else if (!strcmp((char *)curNode->name, "a")) {
                    //NSLog(@"find nodename a");
					childrenAttr |= BCTextNodeLink;
                    
                    //NSLog(@"go to layoutNode");
					[self layoutNode:curNode->children
						  attributes:childrenAttr
						  linkTarget:[NSValue valueWithPointer:curNode]
					 ];
					continue;
                    
				} else if (!strcmp((char *)curNode->name, "br")) {
                    //NSLog(@"find nodename br");
					[self pushNewline];
					whitespaceNeeded = NO;
                    
				} else if (!strcmp((char *)curNode->name, "h4")) {
                    //NSLog(@"find nodename h4");
					childrenAttr |= (BCTextNodeBold | BCTextNodeItalic);
                    
                    //NSLog(@"go to layoutNode");
					[self layoutNode:curNode->children
						  attributes:childrenAttr
						  linkTarget:link];
					[self pushNewline];
					whitespaceNeeded = NO;
					continue;
                    
				} else if (!strcmp((char *)curNode->name, "p")) {
                    //NSLog(@"find nodename p");
					char *class = (char *)xmlGetProp(curNode, (xmlChar *)"class");
					if (NULL != class) {
//						if (!strcmp(class, "editedby") && curNode->children && 
//							!strcmp((char *)curNode->children->name, "span")) {
//							[self pushNewline];
//							[self pushNewline];
//							[self pushImage:@"http://i.somethingawful.com/bullet_wrench.png" linkTarget:link];
//							whitespaceNeeded = NO;
//							childrenAttr |= (BCTextNodeItalic);
//							[self layoutNode:curNode->children attributes:childrenAttr linkTarget:link];
//							free(class);
//							continue;
//						}
						free(class);
					}
				} else if (!strcmp((char *)curNode->name, "div")) {
                    //NSLog(@"find nodename div");
					char *class =(char *)xmlGetProp(curNode, (xmlChar *)"class");
					if (NULL != class) {
						if (!strcmp(class, "bbc-block")) {
							[self pushBlockBorder];
							self.indented = YES;
							[self pushNewline];
                            
                            //NSLog(@"go to layoutNode");
							[self layoutNode:curNode->children
								  attributes:childrenAttr
								  linkTarget:link];
							self.indented = NO;
							[self.lines removeLastObject];
							[self pushBlockBorder];
                            
							[self pushNewline];
							whitespaceNeeded = NO;
							free(class);
							continue;
						} else {
							free(class);
						}
					} 
				} else if (!strcmp((char *)curNode->name, "img")) {
                    //NSLog(@"find nodename img");
                    NSString* text =  [self pushImage:curNode link:link];
                    if (NULL != text && [text length] > 0)
                    {
                        //返回字符串则用text模式显示
                        UIFont *textFont = [self fontWithAttributes:attr];
                        [self pushText:text
                              withFont:textFont
                                  link:link];
                        
                        textLengthCount += (1);

                        if(textLengthCount >= _txtLenLimit){
                            bTextLengthOverflow = YES;
                            break;
                        }
                    }
				}
			}

            //NSLog(@"go to layoutNode");
			[self layoutNode: curNode->children
				  attributes: childrenAttr
				  linkTarget: link];
		}
	}
    
    if(YES == bTextLengthOverflow){
        UIFont* fntExt = NULL;
        if( self.fontSize - 1 > 0){
            fntExt = [UIFont fontWithName:@"Helvetica-Oblique" size:self.fontSize-1];
        }else{
            fntExt = [UIFont fontWithName:@"Helvetica-Oblique" size:self.fontSize];
        }
        [self pushText: @" ...继续阅读"
              withFont: fntExt
                  link: NULL
         ];
    }
}

- (void)drawInRect:(CGRect)rect {
	for (BCTextLine *line in self.lines) {
		if (line.y > rect.size.height) {
			return;
		}
		
		[line drawAtPoint:CGPointMake(rect.origin.x, rect.origin.y + line.y) textColor:self.textColor linkColor:self.linkColor];
        if (singleLine) {
            break;
        }
	}
}

- (BCTextLine *)currentLine {
	return [self.lines lastObject];
}

- (void)setCurrentLine:(BCTextLine *)aLine {
	aLine.y = self.currentLine.y + self.currentLine.height;
	[self.lines addObject:aLine];
}

- (void)setTextLengthLimit:(NSNumber*)numbInteger{
	if(NULL != textLengthLimit){
		[textLengthLimit release];
		textLengthLimit = NULL;
	}
	
	if(NULL != numbInteger){
		textLengthLimit = [numbInteger retain];
	}
}

- (void)setWidth:(CGFloat)aWidth {
	textLengthCount = 0;
	
	self.links = [NSMutableDictionary dictionary];
	width = aWidth;
	self.lines = [NSMutableArray array];
    self.linksInCurrentLine = [NSMutableArray array];
	self.currentLine = [[[BCTextLine alloc] initWithWidth:width] autorelease];
    //NSLog(@"go to layoutNode");
	[self layoutNode: node
		  attributes: BCTextNodePlain
		  linkTarget: nil];
	height = self.currentLine.y + self.currentLine.height;
    
    //调整最后一行
    [self layoutLinksInCurrentLine];
}

- (void)dealloc {
	if (NULL != doc){
		xmlFreeDoc((xmlDoc *)doc);
	}
	node = NULL;
	self.links = nil;
	self.textColor = nil;
	self.linkColor = nil;
	self.lines = nil;
	self.currentLine = nil;
    self.linksInCurrentLine = nil;
	if(NULL != textLengthLimit){
		[textLengthLimit release];
		textLengthLimit = NULL;
	}
	[super dealloc];
}

- (CGFloat)fontSize {
	if (!fontSize) {
		fontSize = 12;
	}
	return fontSize;
}

- (UIFont *)regularFont {
	return [UIFont fontWithName:@"Helvetica" size:self.fontSize];
}

- (UIFont *)boldFont {
	return [UIFont fontWithName:@"Helvetica-Bold" size:self.fontSize];
}

- (UIFont *)italicFont {
	return [UIFont fontWithName:@"Helvetica-Oblique" size:self.fontSize];
}

- (UIFont *)boldItalicFont {
	return [UIFont fontWithName:@"Helvetica-BoldOblique" size:self.fontSize];
}

- (UIFont *)fontWithAttributes:(BCTextNodeAttributes)attr {
	if (attr & BCTextNodeItalic && attr & BCTextNodeBold) {
		return [self boldItalicFont];
	} else if (attr & BCTextNodeItalic) {
		return [self italicFont];
	} else if (attr & BCTextNodeBold) {
		return [self boldFont];
	} else {
		return [self regularFont];
	}
}

- (CGFloat)properWidth {
    if (self.lines.count != 1) {
        return self.width;
        //return maxValue;
    }
    //NSLog(@"properWidth = %4.1f,self.currentLine.width = %4.1f,self.currentLine.widthRemaining = %4.1f",self.currentLine.width - self.currentLine.widthRemaining,self.currentLine.width,self.currentLine.widthRemaining);
    return self.currentLine.width - self.currentLine.widthRemaining;
}

//Objective C 程序实现在图片上添加文字
-(UIImage *)addText:(UIImage *)img text:(NSString *)text1 
{ 
        //get image width and height 
    int w = img.size.width; 
    int h = img.size.height; 
    
    
//    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); 
//        //create a graphic context with CGBitmapContextCreate 
//    CGContextRef context = CGBitmapContextCreate(NULL, w, h, 8, 4 * w, colorSpace, kCGImageAlphaPremultipliedFirst); 
//    CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); 
//    CGContextSetRGBFillColor(context, 0.0, 1.0, 1.0, 1); 
////    char* text = (char *)[text1 cStringUsingEncoding:NSASCIIStringEncoding]; 
//    char* text = (char *)[text1 cStringUsingEncoding:NSUTF8StringEncoding];
////    CGContextSelectFont(context, "Georgia", 30, kCGEncodingMacRoman);
//    CGContextSelectFont(context, "Helvetica", 12, kCGEncodingMacRoman);
//    CGContextSetTextDrawingMode(context, kCGTextFill); 
//    CGContextSetRGBFillColor(context, 255, 0, 0, 1); 
////    CGContextSetTextMatrix(context, CGAffineTransformMakeRotation( -M_PI/4 )); 
////    CGContextShowTextAtPoint(context, 60, 390, text, strlen(text)); 
//    CGContextShowTextAtPoint(context, 20, 20, text, strlen(text)); 
//        //Create image ref from the context 
//    CGImageRef imageMasked = CGBitmapContextCreateImage(context); 
//    CGContextRelease(context); 
//    CGColorSpaceRelease(colorSpace); 
//    return [UIImage imageWithCGImage:imageMasked]; 

    
//    这里可以重新画图，自定义（上面图片，下面文字）
    UIGraphicsBeginImageContext(CGSizeMake(w, h));
    [img drawInRect:CGRectMake(0,0,w,h)];
    
    CGSize size = [text1 sizeWithFont:[UIFont systemFontOfSize:10.0f]
                         constrainedToSize:CGSizeMake(w, h)];
    
    [text1 drawInRect:CGRectMake(w-size.width-10, h-size.height-10, size.width, size.height )
             withFont:[UIFont systemFontOfSize:10.0f]
        lineBreakMode:NSLineBreakByCharWrapping
            alignment:NSTextAlignmentLeft];
    
   
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    return image;
    
}

//Objective C 程序实现在图片上添加文字
-(UIImage *)addText:(UIImage *)img text:(NSString *)text1 withPicSize:(NSString *)picSize
{ 
    //get image width and height 
    int w = img.size.width; 
    int h = img.size.height; 
    
    //    这里可以重新画图，自定义（上面图片，下面文字）
    UIGraphicsBeginImageContext(CGSizeMake(w, h));
    [img drawInRect:CGRectMake(0,0,w,h)];
    CGSize size;
    
    if (text1 && [text1 length]) {
        size = [text1 sizeWithFont:[UIFont systemFontOfSize:10.0f]
                        constrainedToSize:CGSizeMake(w, h)];
        
        [text1 drawInRect:CGRectMake(w-size.width-10, h-size.height-10, size.width, size.height)
                 withFont:[UIFont systemFontOfSize:10.0f]
            lineBreakMode:NSLineBreakByCharWrapping
                alignment:NSTextAlignmentLeft];
    }

    if (picSize && [picSize length]) {
        size = [picSize sizeWithFont:[UIFont systemFontOfSize:10.0f]
                   constrainedToSize:CGSizeMake(w, h)];
        
        [picSize drawInRect:CGRectMake(w-size.width-10, 10, size.width, size.height)
                   withFont:[UIFont systemFontOfSize:10.0f]
              lineBreakMode:NSLineBreakByCharWrapping
                  alignment:NSTextAlignmentLeft];
    }
    
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    return image;
    
}


- (UIImage *)imageForURL:(NSString *)url {

    if ([url hasPrefix:@"smiley://"])
	{
        NSString* imageName = [[url pathComponents] lastObject];

        uint32 dwImgId = (uint32)[[imageName substringWithRange:NSMakeRange(2, imageName.length - 4)] intValue];
       
        UIImage *image = [[ImageManager instance] smileyForId:dwImgId];
        if (image)
        {
			CGFloat smileyWidthDefault = 0;
			CGFloat smileyHeightDefault = 0;
			if (dwImgId >= eSmileyExtTypeCatBegan && dwImgId <= eSmileyExtTypeCatEnd) {
				smileyWidthDefault = EXT_SMILEY_WIDTH_BCTEXT;
				smileyHeightDefault = EXT_SMILEY_HEIGHT_BCTEXT;
			}else{
				smileyWidthDefault = SYS_SMILEY_WIDTH;
				smileyHeightDefault = SYS_SMILEY_HEIGHT;
			}
			if (image.size.width > smileyWidthDefault || image.size.height > smileyHeightDefault)
			{
				return [UIImage reSizeImage:image
									 toSize:(CGSize){
										 .width = smileyWidthDefault,
										 .height = smileyHeightDefault}
						];
			}
			else
			{
				return image;
			}
        }
        else
        {
            //自绘图模糊，暂且不用
//            //当系统里没有这个表情图片，则自绘一个带文字的图。
//            NSString *str = nil;
//            NSString *smileyName = [[ImageManager instance] smileyNameForId:dwImgId];
//            if (!smileyName || !smileyName.length) {
//                str = [NSString stringWithFormat:@" [表情:%i] ", dwImgId];
//            } else {
//                str = [NSString stringWithFormat:@" [表情:%@]",smileyName];
//            }           
//            
//            CGSize size = [str sizeWithFont:[UIFont systemFontOfSize:MSG_TEXT_FONT]];
//            
//            CGFloat w = size.width;
//            CGFloat h = size.height;
//            UIGraphicsBeginImageContext(CGSizeMake(w, h));
//
//            [LIGHT_BROWN_TEXT_COLOR set];
//            [str drawInRect:CGRectMake(0, 0, size.width, size.height)
//                     withFont:[UIFont systemFontOfSize:MSG_TEXT_FONT]
//                lineBreakMode:NSLineBreakByCharWrapping
//                    alignment:NSTextAlignmentLeft];
//            
//            
//            image = UIGraphicsGetImageFromCurrentImageContext();
//            UIGraphicsEndImageContext();
            return nil;
        }
        
    }
    
    if ([url hasPrefix:@"image://"])
	{
        
        if (singleLine)
		{
//            return [ThemeMgr imageNamed:@"chat_msg_photo.png"];
			return nil;
        }
        
        NSString* imageName = [[url pathComponents] lastObject];
        
        NSString *strPicName = [imageName substringWithRange:NSMakeRange(2, imageName.length - 4)];

        NSString *strPicPath = [NSString stringWithFormat:@"%@/pic/%@",
                                [FileConfig4Sys instance].strCachePath,
                                strPicName];
        
        NSError       *error;
        NSFileManager *fm    = [NSFileManager defaultManager];

        
        if ([fm fileExistsAtPath:strPicPath])
        {
            if ([[fm attributesOfItemAtPath:strPicPath error:&error] fileSize] > 10)
            {
                return [UIImage imageWithContentsOfFile:strPicPath];
                
            } else {
                
                if (![[PicDao instance] statusForPicName:strPicName Type:DOWNPICTYPE_PIC])
                {
                    return [self addText:[ThemeMgr imageNamed:@"pic_failed.png"] text:LocalizedStringFromFile(BCTextFrame_lb_Text_DownloadFailed) withPicSize:[[PicNet instance] getPicSizeStr:strPicName]];
                }
                else
                {
                    return [self addText:[ThemeMgr imageNamed:@"pic_start.png"] text:LocalizedStringFromFile(BCTextFrame_lb_Text_Downloading) withPicSize:[[PicNet instance] getPicSizeStr:strPicName]];
                }            
            }
            
        } else {            
            return [self addText:[ThemeMgr imageNamed:@"pic_start.png"] text:LocalizedStringFromFile(BCTextFrame_lb_Text_ClickToDownload) withPicSize:[[PicNet instance] getPicSizeStr:strPicName]];
        }
    }
    
    //暗恋通知 特殊处理
    if ([FileConfig4Sys instance].bHasWeiboServer)
    {
        if ([url hasPrefix:@"imageForXiaoyou://"]) {
            
            if (singleLine) {
                return [ThemeMgr imageNamed:@"chat_msg_photo.png"];
            }
            
            NSString* imageName = [[url pathComponents] lastObject];
            
            NSString *strPicName = [imageName substringWithRange:NSMakeRange(2, imageName.length - 4)];
            
            return [ThemeMgr imageNamed:strPicName];
        }
    }
    
	return nil;
}

- (CGFloat)height {
    if (!singleLine) {
        return height;
    } else {
        if (lines.count == 0) {
            return 0;
        }
        return [[lines objectAtIndex:0] height];
    }
}

@end
